<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Alphabet Sign Maker</title>
  <style>
    :root { --bg:#F6F5F2; --ink:#0B0B0D; --accent:#F3A9B3; --ui:#222; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{background:var(--bg);color:#111;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Helvetica,Arial}
    #app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr}
    header{display:flex;gap:.75rem;align-items:center;padding:.6rem 1rem;border-bottom:1px solid #e5e7eb;background:#fff9}
    h1{font-size:1rem;margin:0 1rem 0 0;font-weight:700}
    .controls{display:flex;flex-wrap:wrap;gap:.5rem .75rem;align-items:center}
    label{font-size:.85rem;color:#4b5563}
    input[type="range"],select,button{appearance:none;background:#fff;color:#111;border:1px solid #e5e7eb;border-radius:10px;padding:.35rem .6rem;font-size:.9rem}
    input[type="range"]{height:32px}
    button{cursor:pointer}
    #stage{display:block;width:100%;height:100%}
    #hud{position:absolute;left:16px;bottom:12px;font-size:.9rem;color:#475569;background:#fff8;border:1px solid #e5e7eb;padding:.4rem .6rem;border-radius:10px}
    .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;background:#111;color:#fff;border-radius:6px;padding:.05rem .35rem}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Alphabet Sign Maker</h1>
      <div class="controls">
        <label>격자 <input id="cols" type="range" min="3" max="14" value="6"/></label>
        <label>모서리 <input id="baseRadius" type="range" min="0" max="36" value="14"/></label>
        <label>여백 <input id="baseInset" type="range" min="0" max="18" value="6"/></label>
        <label>공 속도 <input id="speed" type="range" min="60" max="360" value="160"/></label>
        <button id="save">PNG 저장 (⌅)</button>
        <button id="clear">리셋 (R)</button>
      </div>
    </header>
    <canvas id="stage"></canvas>
    <div id="hud">입력: 알파벳 1글자 · <span class="kbd">Enter</span> 현재 칸 변형 · <span class="kbd">Space</span> 공 찍기 · <span class="kbd">←/→</span> 다음/이전 칸 · <span class="kbd">R</span> 리셋</div>
  </div>

  <script>
    // ===== Canvas bootstrap =====
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    let DPR = Math.min(devicePixelRatio || 1, 2);
    function fit(){
      const w = canvas.clientWidth = innerWidth;
      const h = canvas.clientHeight = innerHeight - document.querySelector('header').offsetHeight;
      canvas.width = Math.floor(w*DPR); canvas.height = Math.floor(h*DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    addEventListener('resize', fit);

    // ===== State =====
    let cols = +document.getElementById('cols').value; // rows derived
    let baseRadius = +document.getElementById('baseRadius').value;
    let baseInset  = +document.getElementById('baseInset').value;
    let letter = 'A';

    // A grid cell is active when the letter occupies it. Each active cell has a mutable style.
    const cells = []; // {i,j, active, r, inset}
    let actives = []; // pointers to active cells
    let cursorIndex = 0; // which active cell is highlighted and auto-advances

    // roaming ball
    const ball = {x: 200, y: 200, vx: 140, vy: 110, r: 56};
    const stamps = []; // placed circles

    // ===== Letter rasterization to grid =====
    const off = document.createElement('canvas');
    const octx = off.getContext('2d');

    function buildGrid(){
      cells.length = 0; actives.length = 0; cursorIndex = 0;
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const pad = Math.min(w,h)*0.08;
      const areaW = w - pad*2, areaH = h - pad*2;
      const rows = Math.round(cols * (areaH/areaW));

      // draw letter to offscreen
      off.width = Math.max(1, cols*24); off.height = Math.max(1, rows*24);
      octx.clearRect(0,0,off.width,off.height);
      octx.fillStyle = '#000';
      octx.textAlign = 'center'; octx.textBaseline='middle';
      const fontSize = Math.min(off.width, off.height)*0.9;
      octx.font = `bold ${fontSize}px system-ui, ui-sans-serif`;
      octx.fillText(letter, off.width/2, off.height/2);

      // sample grid
      for (let j=0;j<rows;j++){
        for (let i=0;i<cols;i++){
          const sx = Math.floor((i+0.5)/cols*off.width);
          const sy = Math.floor((j+0.5)/rows*off.height);
          const data = octx.getImageData(sx, sy, 1, 1).data;
          const active = data[3]>0 && data[0]<200; // simple occupancy test
          const cell = {i,j,active,r:baseRadius,inset:baseInset};
          cells.push(cell);
          if (active) actives.push(cell);
        }
      }

      // layout metrics cached on state for draw
      state.pad = pad; state.rows = rows; state.areaW = areaW; state.areaH = areaH; state.cellW = areaW/cols; state.cellH = areaH/rows;
    }

    const state = {pad:0, rows:0, areaW:0, areaH:0, cellW:0, cellH:0};

    // ===== Drawing helpers =====
    function roundedRect(x,y,w,h,r){
      const rr = Math.max(0, Math.min(r, Math.min(w,h)/2));
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function draw(){
      const {pad, cellW, cellH} = state;
      ctx.clearRect(0,0,canvas.width/DPR, canvas.height/DPR);

      // background frame (poster-like)
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);

      // draw cells
      for (const cell of cells){
        const x = pad + cell.i*cellW, y = pad + cell.j*cellH;
        const inset = Math.max(0, cell.inset);
        const w = cellW - inset*2, h = cellH - inset*2;
        if (!cell.active){
          // ghost grid very light
          ctx.globalAlpha = 0.03; ctx.fillStyle = '#000';
          roundedRect(x+inset,y+inset,w,h, Math.min(cell.r,12));
          ctx.fill(); ctx.globalAlpha = 1; continue;
        }
        ctx.fillStyle = 'black';
        roundedRect(x+inset,y+inset,w,h, cell.r);
        ctx.fill();
      }

      // cursor highlight
      if (actives.length){
        const c = actives[Math.floor(cursorIndex)%actives.length];
        const x = state.pad + c.i*state.cellW + c.inset;
        const y = state.pad + c.j*state.cellH + c.inset;
        const w = state.cellW - c.inset*2, h = state.cellH - c.inset*2;
        ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(243, 169, 179, .9)';
        roundedRect(x,y,w,h, c.r);
        ctx.stroke();
      }

      // ball physics + draw
      stepBall();
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#F3A9B3';
      ctx.beginPath(); ctx.arc(ball.x, ball.y, 22, 0, Math.PI*2); ctx.fill();

      // stamps
      ctx.globalAlpha = .9;
      for (const s of stamps){ ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); }
      ctx.globalAlpha = 1;

      requestAnimationFrame(draw);
    }

    // ===== Ball physics =====
    let last = performance.now();
    function stepBall(){
      const now = performance.now();
      const dt = Math.min(0.04, (now-last)/1000); last = now;
      const speed = +document.getElementById('speed').value; // px/s approximated
      const s = speed*dt;
      ball.x += ball.vx/160*s; ball.y += ball.vy/160*s;
      const w = canvas.clientWidth, h = canvas.clientHeight;
      if (ball.x<24||ball.x>w-24){ ball.vx*=-1; ball.x = Math.max(24, Math.min(w-24, ball.x)); }
      if (ball.y<24||ball.y>h-24){ ball.vy*=-1; ball.y = Math.max(24, Math.min(h-24, ball.y)); }
    }

    // ===== Interactions =====
    function mutateCurrentCell(){
      if (!actives.length) return;
      const c = actives[Math.floor(cursorIndex)%actives.length];
      // random small mutation: toggle corner radius or inset (gap)
      const coin = Math.random();
      if (coin<.5){ c.r = Math.max(0, Math.min(Math.min(state.cellW,state.cellH)/2, c.r + (Math.random()<.5? -1:1) * (6 + Math.random()*10))); }
      else { c.inset = Math.max(0, c.inset + (Math.random()<.5? -1:1) * (2 + Math.random()*6)); }
    }

    function stampBall(){ stamps.push({x:ball.x, y:ball.y, r: 36}); }

    // auto cursor wander
    setInterval(()=>{ if (actives.length) cursorIndex = (cursorIndex + 1) % actives.length; }, 650);

    document.addEventListener('keydown', (e)=>{
      if (e.metaKey||e.ctrlKey||e.altKey) return;
      const k = e.key;
      if (k.length===1 && /[A-Za-z]/.test(k)){
        letter = k.toUpperCase(); buildGrid(); return;
      }
      if (k==='Enter'){ mutateCurrentCell(); return; }
      if (k===' '){ e.preventDefault(); stampBall(); mutateCurrentCell(); return; }
      if (k==='ArrowRight'){ cursorIndex = (cursorIndex+1) % Math.max(1, actives.length); return; }
      if (k==='ArrowLeft'){ cursorIndex = (cursorIndex-1+Math.max(1, actives.length)) % Math.max(1, actives.length); return; }
      if (k==='r' || k==='R'){ buildGrid(); stamps.length = 0; return; }
    }, {passive:false});

    document.getElementById('save').addEventListener('click', ()=>{
      const a = document.createElement('a');
      a.download = `sign-${letter}-${Date.now()}.png`;
      a.href = canvas.toDataURL('image/png');
      a.click();
    });
    document.getElementById('clear').addEventListener('click', ()=>{ buildGrid(); stamps.length=0; });

    document.getElementById('cols').addEventListener('input', e=>{ cols=+e.target.value; buildGrid(); });
    document.getElementById('baseRadius').addEventListener('input', e=>{ baseRadius=+e.target.value; for(const c of cells){ c.r=baseRadius; } });
    document.getElementById('baseInset').addEventListener('input', e=>{ baseInset=+e.target.value; for(const c of cells){ c.inset=baseInset; } });

    // init
    fit();
    buildGrid();
    draw();
  </script>
</body>
</html>
